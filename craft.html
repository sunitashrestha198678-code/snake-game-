<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>MiniCraft — Chunked Terrain with Trees</title>
<style>
  html,body{height:100%;margin:0;font-family:Inter,Arial,Helvetica,sans-serif;background:#000}
  #container{width:100%;height:100%;position:relative;overflow:hidden}
  #hud{position:absolute;left:12px;top:12px;background:rgba(0,0,0,0.35);color:#fff;padding:10px;border-radius:8px;font-size:13px}
  #msg{position:absolute;left:50%;transform:translateX(-50%);bottom:18px;background:rgba(0,0,0,0.45);color:#fff;padding:8px 12px;border-radius:8px}
  .small{opacity:0.9;font-size:12px}
</style>
</head>
<body>
<div id="container"></div>
<div id="hud">Chunks loaded: <span id="chunkCount">0</span> • Blocks: <span id="blockCount">0</span></div>
<div id="msg">Click to lock pointer • WASD to move • Mouse to look • R to regen</div>

<script src="https://unpkg.com/three@0.153.0/build/three.min.js"></script>
<script>
// --- Config
const CHUNK_SIZE = 16; // blocks per side
const VISIBLE_RADIUS = 3; // chunks in each direction
const BLOCK_SIZE = 1;
const MAX_HEIGHT = 20;
const SEED = Math.floor(Math.random()*65536);

// --- Setup scene
const container = document.getElementById('container');
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x87ceeb);

const camera = new THREE.PerspectiveCamera(75, innerWidth/innerHeight, 0.1, 1000);
camera.position.set(0, 20, 40);

const renderer = new THREE.WebGLRenderer({antialias:true});
renderer.setPixelRatio(devicePixelRatio);
renderer.setSize(innerWidth, innerHeight);
container.appendChild(renderer.domElement);

const hemi = new THREE.HemisphereLight(0xffffff, 0x444444, 0.9); scene.add(hemi);
const dir = new THREE.DirectionalLight(0xffffff, 0.6); dir.position.set(50,100,50); scene.add(dir);

// fog for depth realism
scene.fog = new THREE.FogExp2(0x87ceeb, 0.0025);

// Pointer lock controls (minimal)
let yaw=0,pitch=0, move={f:0,b:0,l:0,r:0};
const speed = 8;
renderer.domElement.style.cursor='pointer';
renderer.domElement.addEventListener('click', ()=>{ renderer.domElement.requestPointerLock(); });

function onMouseMove(e){ yaw -= e.movementX * 0.0025; pitch -= e.movementY * 0.0025; pitch = Math.max(-Math.PI/2+0.01, Math.min(Math.PI/2-0.01, pitch)); }

document.addEventListener('pointerlockchange', ()=>{
  if(document.pointerLockElement===renderer.domElement) document.addEventListener('mousemove', onMouseMove);
  else document.removeEventListener('mousemove', onMouseMove);
});

window.addEventListener('keydown', (e)=>{ if(e.code==='KeyW') move.f=1; if(e.code==='KeyS') move.b=1; if(e.code==='KeyA') move.l=1; if(e.code==='KeyD') move.r=1; if(e.code==='KeyR') regenerate(); });
window.addEventListener('keyup', (e)=>{ if(e.code==='KeyW') move.f=0; if(e.code==='KeyS') move.b=0; if(e.code==='KeyA') move.l=0; if(e.code==='KeyD') move.r=0; });

// simple perlin noise (improved) - small and fast implementation
// Source: adapted classic improved Perlin
class Perlin {
  constructor(seed=0){ this.p = new Uint8Array(512); const rng = mulberry32(seed); for(let i=0;i<256;i++) this.p[i]=i; for(let i=255;i>0;i--){ const j = Math.floor(rng()* (i+1)); const t = this.p[i]; this.p[i]=this.p[j]; this.p[j]=t; } for(let i=0;i<256;i++) this.p[i+256]=this.p[i]; }
  fade(t){ return t*t*t*(t*(t*6-15)+10); }
  lerp(a,b,t){return a + t*(b-a);} 
  grad(hash,x,y,z){ const h = hash & 15; const u = h<8 ? x : y; const v = h<4 ? y : (h===12||h===14? x : z); return ((h&1)? -u : u) + ((h&2)? -v : v); }
  noise(x,y=0,z=0){ const X = Math.floor(x)&255, Y=Math.floor(y)&255, Z=Math.floor(z)&255; x-=Math.floor(x); y-=Math.floor(y); z-=Math.floor(z); const u=this.fade(x), v=this.fade(y), w=this.fade(z); const A=this.p[X]+Y, AA=this.p[A]+Z, AB=this.p[A+1]+Z, B=this.p[X+1]+Y, BA=this.p[B]+Z, BB=this.p[B+1]+Z; return this.lerp(this.lerp(this.lerp(this.grad(this.p[AA],x,y,z), this.grad(this.p[BA],x-1,y,z),u), this.lerp(this.grad(this.p[AB],x,y-1,z), this.grad(this.p[BB],x-1,y-1,z),u), v), this.lerp(this.lerp(this.grad(this.p[AA+1],x,y,z-1), this.grad(this.p[BA+1],x-1,y,z-1),u), this.lerp(this.grad(this.p[AB+1],x,y-1,z-1), this.grad(this.p[BB+1],x-1,y-1,z-1),u), v), w);
  }
}
function mulberry32(a){ return function(){ let t = a += 0x6D2B79F5; t = Math.imul(t ^ t>>>15, t | 1); t ^= t + Math.imul(t ^ t>>>7, t | 61); return ((t ^ t>>>14) >>> 0) / 4294967296; } }

const perlin = new Perlin(SEED);
function fractalNoise(x,z,octaves=4, lacunarity=2, gain=0.5){ let amp=1, freq=1, sum=0, max=0; for(let i=0;i<octaves;i++){ sum += perlin.noise(x*freq*0.02, z*freq*0.02) * amp; max += amp; amp *= gain; freq *= lacunarity; } return sum / max; }

// block palette
const BLOCKS = [ {name:'grass', color:0x88cc55}, {name:'dirt', color:0x8b5a2b}, {name:'stone', color:0x9e9e9e}, {name:'wood', color:0x8b4513}, {name:'leaves', color:0x2e8b57} ];

// chunk manager
const chunks = new Map(); // key: cx,cz -> chunk object
const chunkCountEl = document.getElementById('chunkCount');
const blockCountEl = document.getElementById('blockCount');
let totalBlocks = 0;

function ckey(cx,cz){ return `${cx},${cz}`; }

// create materials once (for instanced meshes per type)
const materials = BLOCKS.map(b => new THREE.MeshStandardMaterial({color: b.color}));

// basic box geometry for block
const boxGeo = new THREE.BoxGeometry(BLOCK_SIZE,BLOCK_SIZE,BLOCK_SIZE);

function generateChunk(cx, cz){
  const key = ckey(cx,cz);
  if(chunks.has(key)) return chunks.get(key);
  // determine blocks within chunk
  const blocksByType = {}; let count=0;
  for(let x=0;x<CHUNK_SIZE;x++){
    for(let z=0;z<CHUNK_SIZE;z++){
      const worldX = cx*CHUNK_SIZE + x;
      const worldZ = cz*CHUNK_SIZE + z;
      // height from fractal noise
      const n = fractalNoise(worldX, worldZ, 5, 2, 0.5);
      let h = Math.floor((n*0.5 + 0.5) * (MAX_HEIGHT-4)) + 2; // normalize to 0..1 then scale
      h = Math.max(1, Math.min(MAX_HEIGHT-1,h));
      // base layers and top
      for(let y=0;y<h;y++){
        const type = (y< h-1) ? 1 : 0; // dirt below, grass on top
        if(!blocksByType[type]) blocksByType[type]=[];
        blocksByType[type].push({x:worldX, y, z:worldZ}); count++;
      }
      // some stone deeper
      if(h>6){ for(let y=0;y<Math.min(3,h-3);y++){ const type=2; if(!blocksByType[type]) blocksByType[type]=[]; blocksByType[type].push({x:worldX, y:y, z:worldZ}); } }
      // place trees with small prob on top
      if(Math.random() < 0.02){ placeTreeAt(worldX, h, worldZ, blocksByType); }
    }
  }

  // Create InstancedMeshes per type
  const group = new THREE.Group(); group.position.set(0,0,0);
  let localBlocks = 0;
  Object.keys(blocksByType).forEach(typeKey =>{
    const arr = blocksByType[typeKey];
    const mat = materials[typeKey];
    const mesh = new THREE.InstancedMesh(boxGeo, mat, arr.length);
    mesh.instanceMatrix.setUsage(THREE.DynamicDrawUsage);
    let idx=0;
    const tmp = new THREE.Object3D();
    arr.forEach(b=>{ tmp.position.set(b.x + 0.5, b.y + 0.5, b.z + 0.5); tmp.updateMatrix(); me
