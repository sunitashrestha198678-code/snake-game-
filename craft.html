<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>MiniCraft — simple browser voxel demo</title>
  <style>
    html,body{height:100%;margin:0;font-family:Arial,Helvetica,sans-serif;overflow:hidden}
    #canvas-container{width:100%;height:100%;display:block;position:relative;background:#86c0ff}
    #hud{position:absolute;left:12px;top:12px;background:rgba(0,0,0,0.4);color:#fff;padding:8px;border-radius:6px}
    #palette{display:flex;gap:6px;margin-top:6px}
    .swatch{width:28px;height:28px;border-radius:4px;cursor:pointer;box-shadow:0 0 0 2px rgba(255,255,255,0.06) inset}
    .swatch.active{outline:2px solid #fff}
    #message{position:absolute;left:50%;transform:translateX(-50%);bottom:18px;background:rgba(0,0,0,0.45);color:#fff;padding:6px 10px;border-radius:6px}
    #blockCount{font-size:13px;opacity:0.9}
    #help{font-size:13px;opacity:0.95}
    a.small{color:#fff;text-decoration:underline}
  </style>
</head>
<body>
  <div id="canvas-container"></div>
  <div id="hud">
    <div id="help">Click to lock pointer — WASD to move • Mouse to look • Left click remove • Right click place</div>
    <div id="palette"></div>
    <div id="blockCount"></div>
  </div>
  <div id="message">Tip: press <strong>R</strong> to reset the world</div>

  <script src="https://unpkg.com/three@0.153.0/build/three.min.js"></script>
  <script>
    // Minimal Minecraft-like voxel builder
    const container = document.getElementById('canvas-container');
    const paletteEl = document.getElementById('palette');
    const blockCountEl = document.getElementById('blockCount');

    // Three.js setup
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
    camera.position.set(0, 6, 10);

    const renderer = new THREE.WebGLRenderer({antialias:true});
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(window.devicePixelRatio);
    container.appendChild(renderer.domElement);

    // lights
    const hemi = new THREE.HemisphereLight(0xffffff, 0x444444, 0.8);
    scene.add(hemi);
    const dir = new THREE.DirectionalLight(0xffffff, 0.6);
    dir.position.set(5,10,7);
    scene.add(dir);

    // ground plane (invisible physics base)
    const groundGeo = new THREE.PlaneGeometry(200,200);
    const groundMat = new THREE.MeshStandardMaterial({visible:false});
    const ground = new THREE.Mesh(groundGeo, groundMat);
    ground.rotation.x = -Math.PI/2;
    scene.add(ground);

    // simple skybox color
    scene.background = new THREE.Color(0x87ceeb);

    // block types palette
    const BLOCKS = [
      {name:'Grass', color:0x88cc55},
      {name:'Dirt',  color:0x8b5a2b},
      {name:'Stone', color:0x9e9e9e},
      {name:'Wood',  color:0x8b4513},
      {name:'Sand',  color:0xf4e7a0}
    ];
    let selectedBlock = 0;

    // create palette UI
    BLOCKS.forEach((b, i) => {
      const sw = document.createElement('div');
      sw.className = 'swatch' + (i===0? ' active':'');
      sw.title = b.name;
      sw.style.background = '#' + b.color.toString(16).padStart(6,'0');
      sw.addEventListener('click', ()=>{
        selectedBlock = i; document.querySelectorAll('.swatch').forEach((el,idx)=>el.classList.toggle('active', idx===i));
      });
      paletteEl.appendChild(sw);
    });

    // world storage
    const blocks = new Map(); // key = `${x},${y},${z}` -> mesh
    const blockSize = 1;
    const cubeGeo = new THREE.BoxGeometry(blockSize, blockSize, blockSize);

    function key(x,y,z){return `${x},${y},${z}`}

    function addBlock(x,y,z,typeIndex){
      const k = key(x,y,z);
      if(blocks.has(k)) return null;
      const mat = new THREE.MeshStandardMaterial({color:BLOCKS[typeIndex].color});
      const m = new THREE.Mesh(cubeGeo, mat);
      m.position.set(x*blockSize + blockSize/2, y*blockSize + blockSize/2, z*blockSize + blockSize/2);
      m.userData = {x,y,z,typeIndex};
      scene.add(m);
      blocks.set(k,m);
      updateBlockCount();
      return m;
    }
    function removeBlock(x,y,z){
      const k = key(x,y,z);
      const m = blocks.get(k);
      if(!m) return false;
      scene.remove(m);
      blocks.delete(k);
      updateBlockCount();
      return true;
    }

    function updateBlockCount(){ blockCountEl.textContent = `Blocks: ${blocks.size}` }

    // generate a small island/flat world
    function generateWorld(){
      // clear
      for(const k of Array.from(blocks.keys())){ removeBlock(...k.split(',').map(Number)); }
      const size = 16;
      for(let x=-size/2; x<size/2; x++){
        for(let z=-size/2; z<size/2; z++){
          const h = (Math.random()*1.2)|0; // 0 or 1 high
          addBlock(x,0,z,1); // dirt base
          addBlock(x,1,z,0); // grass on top
          if(Math.random()<0.03) addBlock(x,2,z,3); // occasional tree trunk single-block (simple)
        }
      }
    }

    generateWorld();

    // simple first-person camera controls using Pointer Lock and manual yaw/pitch
    let yaw = 0, pitch = 0;
    let move = {forward:false,back:false,left:false,right:false};
    let velocity = new THREE.Vector3();
    const speed = 6;

    // pointer lock
    const instructions = renderer.domElement;
    instructions.style.cursor = 'pointer';
    instructions.addEventListener('click', ()=>{ if(document.pointerLockElement !== renderer.domElement) renderer.domElement.requestPointerLock(); });

    document.addEventListener('pointerlockchange', ()=>{
      if(document.pointerLockElement===renderer.domElement){ document.addEventListener('mousemove', onMouseMove); }
      else { document.removeEventListener('mousemove', onMouseMove); }
    });

    function onMouseMove(e){
      const movementX = e.movementX || 0;
      const movementY = e.movementY || 0;
      yaw -= movementX * 0.0025;
      pitch -= movementY * 0.0025;
      pitch = Math.max(-Math.PI/2 + 0.01, Math.min(Math.PI/2 - 0.01, pitch));
    }

    // keyboard
    window.addEventListener('keydown', (e)=>{
      if(e.code==='KeyW') move.forward=true;
      if(e.code==='KeyS') move.back=true;
      if(e.code==='KeyA') move.left=true;
      if(e.code==='KeyD') move.right=true;
      if(e.code==='KeyR') generateWorld();
    });
    window.addEventListener('keyup', (e)=>{
      if(e.code==='KeyW') move.forward=false;
      if(e.code==='KeyS') move.back=false;
      if(e.code==='KeyA') move.left=false;
      if(e.code==='KeyD') move.right=false;
    });

    // raycaster for block interactions
    const raycaster = new THREE.Raycaster();
    const mouse = new THREE.Vector2();

    // helper - world position from intersection face
    function faceToAdjacentPosition(intersect){
      const face = intersect.face;
      const point = intersect.point;
      // determine block coords of the intersected mesh
      const m = intersect.object;
      const {x,y,z} = m.userData;
      // face normal in world space approximated by face.normal and mesh rotation (we don't rotate meshes)
      const normal = face.normal;
      // adjacent position = original block pos + normal
      const ax = x + Math.round(normal.x);
      const ay = y + Math.round(normal.y);
      const az = z + Math.round(normal.z);
      return {ax,ay,az};
    }

    // on mousedown: left remove, right place
    renderer.domElement.addEventListener('mousedown', (e)=>{
      if(document.pointerLockElement !== renderer.domElement) return; // only when locked
      e.preventDefault();
      // cast a ray from camera center
      raycaster.setFromCamera({x:0,y:0}, camera);
      const intersects = raycaster.intersectObjects(Array.from(blocks.values()));
      if(intersects.length===0) return;
      const first = intersects[0];
      if(e.button===0){ // left - remove
        const {x,y,z} = first.object.userData;
        // prevent removing too many base blocks (optional) - allow removal
        removeBlock(x,y,z);
      } else if(e.button===2){ // right - place
        const {ax,ay,az} = faceToAdjacentPosition(first);
        addBlock(ax,ay,az, selectedBlock);
      }
    });

    // prevent context menu so right click works
    renderer.domElement.addEventListener('contextmenu', (e)=>{ e.preventDefault(); });

    // animation loop
    const clock = new THREE.Clock();
    function animate(){
      const dt = clock.getDelta();
      // camera orientation
      camera.rotation.order = 'YXZ';
      camera.rotation.y = yaw;
      camera.rotation.x = pitch;

      // movement vector
      const forward = new THREE.Vector3(Math.sin(yaw),0,Math.cos(yaw));
      const right = new THREE.Vector3(Math.sin(yaw+Math.PI/2),0,Math.cos(yaw+Math.PI/2));
      velocity.set(0,0,0);
      if(move.forward) velocity.add(forward);
      if(move.back) velocity.sub(forward);
      if(move.left) velocity.add(right);
      if(move.right) velocity.sub(right);
      if(velocity.lengthSq()>0) velocity.normalize().multiplyScalar(speed*dt);
      camera.position.add(velocity);

      // keep camera above ground (simple)
      camera.position.y = Math.max(camera.position.y, 1.6);

      renderer.render(scene, camera);
      requestAnimationFrame(animate);
    }
    animate();

    // responsive
    window.addEventListener('resize', ()=>{ camera.aspect = window.innerWidth/window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); });

    // small helpers: show crosshair and highlight targeted block by slightly outlining
    const cross = document.createElement('div');
    cross.style.position='absolute'; cross.style.left='50%'; cross.style.top='50%'; cross.style.transform='translate(-50%,-50%)'; cross.style.width='12px'; cross.style.height='12px'; cross.style.pointerEvents='none'; cross.style.borderLeft='2px solid rgba(255,255,255,0.8)'; cross.style.borderTop='2px solid rgba(255,255,255,0.8)'; container.appendChild(cross);

    // optional: show highlight cube when pointing
    const highlightMat = new THREE.MeshBasicMaterial({color:0xffffff,wireframe:true,transparent:true,opacity:0.6});
    const highlightMesh = new THREE.Mesh(cubeGeo, highlightMat);
    highlightMesh.visible = false; scene.add(highlightMesh);

    // update highlight each frame using raycaster
    function updateHighlight(){
      if(document.pointerLockElement!==renderer.domElement){ highlightMesh.visible=false; return; }
      raycaster.setFromCamera({x:0,y:0}, camera);
      const intersects = raycaster.intersectObjects(Array.from(blocks.values()));
      if(intersects.length===0){ highlightMesh.visible=false; return; }
      const first = intersects[0];
      const {x,y,z} = first.object.userData;
      highlightMesh.position.set(x + 0.5, y + 0.5, z + 0.5);
      highlightMesh.visible = true;
    }

    // integrate highlight update into render loop by wrapping render
    const originalRender = renderer.render.bind(renderer);
    renderer.render = function(){ updateHighlight(); originalRender(scene, camera); };

    // Prevent accidental text selection
    document.body.style.userSelect = 'none';

    // initial block count update
    updateBlockCount();

    // small note for users who open file locally
    console.log('MiniCraft demo ready — click canvas to lock pointer.');
  </script>
</body>
</html>
